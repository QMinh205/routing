####################################################
# LSrouter.py
# Name:
# HUID:
#####################################################

from router import Router
import networkx
import json
from packet import Packet
ENDPOINT = 0

class LSrouter(Router):
    """Link state routing protocol implementation.

    Add your own class fields and initialization code (e.g. to create forwarding table
    data structures). See the `Router` base class for docstrings of the methods to
    override.
    """

    def __init__(self, addr, heartbeat_time):
        Router.__init__(self, addr)  # Initialize base class - DO NOT REMOVE
        self.heartbeat_time = heartbeat_time
        self.last_time = 0
        
        # store ls of global network
        #   addr: {addr: cost}
        self.link_state_db= {addr: {} }
        
        # track seq_numbers for each neighbor
        #   addr: seq_number
        self.seq_numbers = {addr: 0}
        
        # dst: next_hop
        self.forwarding_table = {}
        
        # port: (endpoint, cost)
        self.neighbors = {}
        
    def handle_packet(self, port, packet):
        """Process incoming packet."""
        # TODO
        if packet.is_traceroute:
            # Hint: this is a normal data packet
            # If the forwarding table contains packet.dst_addr
            #   send packet based on forwarding table, e.g., self.send(port, packet)
            if self.forwarding_table.get(packet.dst_addr):
                next_hop = self.forwarding_table[packet.dst_addr]
                self.send(next_hop, packet)
        else:
            try:
                # Hint: this is a routing packet generated by your routing protocol
                seq_number = json.loads(packet.content)["seq_number"]
                addr = json.loads(packet.content)["addr"]
                link_state = json.loads(packet.content)["link_state"]
                
                if addr not in self.seq_numbers:
                    self.seq_numbers[addr] = 0
                    
                is_new = False
                if addr not in self.seq_numbers:
                    is_new = True
                elif seq_number > self.seq_numbers[addr]:
                    is_new = True
                
                # If the sequence number is higher
                if is_new:
                    self.seq_numbers[packet.src_addr] = seq_number
                    
                    #update the local copy of the link state
                    self.link_state_db[addr] = link_state
                    
                    #update the forwarding table
                    self.compute_shortest_paths()
                    
                    #broadcast the packet to other neighbors
                    self.broadcast_link_state_packet(packet.content, port)
            except (json.JSONDecodeError,KeyError):
                print("Error decoding JSON:", KeyError)
                return

    def handle_new_link(self, port, endpoint, cost):
        """Handle new link."""
        # TODO
        #   update local data structures and forwarding table
        self.neighbors[port] = (endpoint, cost)
        
        self.link_state_db[self.addr][endpoint] = cost
        
        if self.seq_numbers.get(self.addr) is None:
            self.seq_numbers[self.addr] = 0
        self.seq_numbers[self.addr] += 1
        
        
        #   broadcast the new link state of this router to all neighbors
        self.send_link_state_packet()

    def handle_remove_link(self, port):
        """Handle removed link."""
        # TODO
        #   update local data structures and forwarding table
        if port not in self.neighbors:
            return
        
        endpoint = self.neighbors[port][ENDPOINT]
        del self.neighbors[port]
        del self.link_state_db[self.addr][endpoint]
        
        self.seq_numbers[self.addr] += 1
        
        del self.forwarding_table[endpoint]
                
        #   broadcast the new link state of this router to all neighbors
        self.send_link_state_packet()
        
    def handle_time(self, time_ms):
        """Handle current time."""
        if time_ms - self.last_time >= self.heartbeat_time:
            self.last_time = time_ms
            # TODO
            #   broadcast the link state of this router to all neighbors
            self.send_link_state_packet()
            
    def compute_shortest_paths(self):
        """Compute shortest paths to all nodes in the network."""
        # TODO
        #   Use the link state database to compute the shortest path to each node
        #   Update the forwarding table accordingly
        graph = networkx.Graph()
        
        for addr in self.link_state_db:
            graph.add_node(addr)
            for neighbor in self.link_state_db[addr]:
                cost = self.link_state_db[addr][neighbor]
                graph.add_edge(addr, neighbor, weight=cost)
        
        # for router, links in self.link_state_db.items():
        #     if router not in graph:
        #         graph.add_node(router)
        #     for neighbor, cost in links.items():
        #         if neighbor not in graph:
        #             graph.add_node(neighbor)
        #         graph.add_edge(router, neighbor, weight=cost)
        paths = networkx.single_source_dijkstra(graph, self.addr)[1]
        
        for addr in paths:
            if addr == self.addr:
                continue
            
            # find the next hop
            next_hop = None
            for port in self.neighbors:
                if self.neighbors[port][ENDPOINT] == addr:
                    next_hop = port
                    break
            
            # update the forwarding table
            if next_hop is not None:
                self.forwarding_table[addr] = next_hop
        
        #then compute the shortest path
        networkx.single_source_dijkstra(graph, self.addr)
        #update the forwarding table
    
    def broadcast_link_state_packet(self, packet_content,received_port):
        """Broadcast the link state to all neighbors."""
        for port in self.neighbors:
            if port == received_port:
                continue
            dst = self.neighbors[port][0]
            packet = Packet(Packet.ROUTING, self.addr, dst, packet_content)
            self.send(port, packet)
        
    
    def send_link_state_packet(self):
        # send own Link State packet to all neighbors
        packet_data ={
            "link_state": self.link_state_db[self.addr],
            "seq_number": self.seq_numbers[self.addr],
            "addr": self.addr
        }
        self.broadcast_link_state_packet(json.dumps(packet_data), None)
        
    def __repr__(self):
        """Representation for debugging in the network visualizer."""

        # TODO
        #   NOTE This method is for your own convenience and will not be graded
        
        return f"LSrouter(addr={self.addr} \n{self.neighbors} \n{self.link_state_db} \n{self.seq_numbers} \n{self.forwarding_table})"
