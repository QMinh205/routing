####################################################
# LSrouter.py
# Name:
# HUID:
#####################################################

from router import Router


class LSrouter(Router):
    """Link state routing protocol implementation.

    Add your own class fields and initialization code (e.g. to create forwarding table
    data structures). See the `Router` base class for docstrings of the methods to
    override.
    """

    def __init__(self, addr, heartbeat_time):
        Router.__init__(self, addr)  # Initialize base class - DO NOT REMOVE
        self.heartbeat_time = heartbeat_time
        self.last_time = 0
        # TODO
        #   add your own class fields and initialization code here
        pass

    def handle_packet(self, port, packet):
        """Process incoming packet."""
        # TODO
        if packet.is_traceroute:
            # Hint: this is a normal data packet
            # If the forwarding table contains packet.dst_addr
            #   send packet based on forwarding table, e.g., self.send(port, packet)
            pass
        else:
            # Hint: this is a routing packet generated by your routing protocol
            # If the sequence number is higher and the received link state is different
            #   update the local copy of the link state
            #   update the forwarding table
            #   broadcast the packet to other neighbors
            pass

    def handle_new_link(self, port, endpoint, cost):
        """Handle new link."""
        # TODO
        #   update local data structures and forwarding table
        #   broadcast the new link state of this router to all neighbors
        pass

    def handle_remove_link(self, port):
        """Handle removed link."""
        # TODO
        #   update local data structures and forwarding table
        #   broadcast the new link state of this router to all neighbors
        pass

    def handle_time(self, time_ms):
        """Handle current time."""
        if time_ms - self.last_time >= self.heartbeat_time:
            self.last_time = time_ms
            #   broadcast the link state of this router to all neighbors
            self.send_link_state_packet()

    def compute_shortest_paths(self):
        """Compute shortest paths to all nodes in the network."""
        #   Use the link state database to compute the shortest path to each node
        graph = networkx.Graph()
        
        for addr in self.link_state_db:
            graph.add_node(addr)
            for neighbor in self.link_state_db[addr]:
                cost = self.link_state_db[addr][neighbor]
                graph.add_edge(addr, neighbor, weight=cost)

        paths = networkx.single_source_dijkstra_path(graph, self.addr)
        
        #   Update the forwarding table accordingly
        self.forwarding_table = {}
        for addr in paths:
            if addr == self.addr:
                continue
            
            # find the next hop of paths[addr][1]
            for port in self.neighbors:
                if self.neighbors[port] == paths[addr][1]:
                    self.forwarding_table[addr] = port
                    break
    def __repr__(self):
        """Representation for debugging in the network visualizer."""
        #   NOTE This method is for your own convenience and will not be graded
        return f"LSrouter(addr={self.addr} \n{self.neighbors} \n{self.forwarding_table})"